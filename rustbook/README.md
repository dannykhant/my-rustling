# Rust

- Variables
    - Immutable is default
    - Constants
        - Must always annotate types
        - Evaluation when declaring constant
    - Shadowing
        - Helps to use var w/o name extension like var_str, var_count
- Data types
    - Scalar
        - Integers
            - signed - i32
            - unsigned - u32
        - Floating-point numbers
            - f64
        - Boolean
            - One byte in size
            - bool
        - Characters
            - Four bytes in size
            - char
    - Compound
        - Tuples
            - Grouping multiple types into one compound type
            - Without values - unit type `()`
            - Period (.) is used to access index of the value
                - tuple.0
        - Arrays
            - All members must be same type
            - Arrays have a fixed length
            - For repetitive same value
                - [3; 5] == [3, 3, 3, 3, 3]
- Functions
    - Uses snake case
    - Parameters
        - Must declare type
    - Statements & Expressions
        - Statements - Take action and NOT return value
        - Expressions - Evaluate a resultant value
            - Do not include ending semicolon
            - Adding semicolon turn expression into statement
- Control Flow
    - `if` is an expression
    - `loop` will loop forever
        - Loop labels begin with a single quote
    - `break` can be used with return value
    - `while` chosen over `loop` for collections
    - `for` is more concise and safe with collections
- Ownership
    - Enables Rust to make memory safety guarantees without needing a garbage collector
    - Set of rules that govern managing memory
    - Main purpose is to manage heap data
    - Memory
        - Stack
            - Last in, first out
            - Known, fixed size data
            - Analogy: a stack of plates
        - Heap
            - Allocating
                - find empty spot → mark it in use → return a pointer
            - Pointer to the heap is known, fixed size and it must follow the pointer for actual data
            - Analogy: being seated at a restaurant
        - Stack is faster than Heap because allocator never has to search for a place to store data in Stack
        - When calling a function, the values passed into function and functions local variables are pushed into Stack and those values are removed when the function is over
    - **Ownership Rules**
        - **Each value in Rust has an owner.**
        - **There can only be one owner at a time.**
        - **When the owner goes out of scope, the value will be dropped.**
    - Move
        - Rust call drop function to clear heap in the end of scope
        - Rust invalidate the first variable when copying the pointer to the 2nd variable, it is know as a **move** (shallow clone in other)
    - Deep copy
        - `clone()` is used to deeply copy the heap data
    - Assignment
        - Rust will free original value memory when new value is assigned to the existing variable
    - Copy trait
        - interger, boolean, floating-point, char, Tuples
    - Function with Ownership
        - Passing value will transfer ownership to function parameter
    - Return
        - Returning value will transfer ownership to receiver variable
- Reference
    - It is like a pointer but guaranteed to point to a valid value for the life of that reference
    - Reference are immutable by default
    - Borrowing
        - The action of creating a reference is called borrowing
    - Mutable Reference
        - To prevent data race
            - Allows only ONE mutable reference to a value if there is a usage later
                - mut ref1 → mut ref2 → use(ref1, ref2) doen’t work
                - ref1 → ref2 → mut ref3 → use(ref1, ref2, ref3) doesn’t work
                - ref1 → ref2 → use(ref1, ref2) → mut ref3 → use(ref3) works
    - Dangling Reference
        - A pointer that reference a location that may have been given to someone else
    - **Rules of Reference**
        - **At any given time, you can have either one mutable reference or any number of immutable references.**
        - **References must always be valid.**
- Slice Type
    - Referencing continuous sequence of elements
    - It is a kind of Reference, so doesn’t have ownership
    - String Slices
        - It is a immutable reference to contiguous sequence of the elements of a String
        - The type of it is written as `&str`
- Structs
    - Struct is like object’s data attributes
    - `.` is used to access Struct instance’s fields
        - user1.email
    - Can access data of other Struct instance in a Struct instance
    - Field init shorthand is useful for the same names
    - `..` can be used as struct update from another Struct instance
        - The first Struct instance might not be used again if the ownership of the field is transferred
    - Tuple Structs
        - It requires the name of the type of struct when destructure it
    - Unit-like Structs
        - Useful to implement trait but don’t have any data
    - To store reference in Struct, it requires to use Lifetimes
    - Debug specifier `:?` in println! macro
- Method Syntax
    - Methods are defined within the context of a struct or enum or trait object
    - The first parameter of methods is always `self`
    - `&self` is equal to `self: &Self`
    - Associated Functions
        - All functions defined in `impl` are called associated functions
        - They don’t have `self` as first parameter
        - `::` syntax is used for associated functions and namespaces
        - `Self` keyword represents as the Struct
    - Each Struct is allowed to have multiple `impl` blocks
- Enum
    -